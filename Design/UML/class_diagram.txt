Core Domain Classes

class LogEvent
{
- eventID : String
- serviceName : String
- timestamp : DateTime
- logLevel : String
- message : String
- rawLog : String
- parsed : Boolean

+ normalize() : void
+ isValid() : Boolean
}


class DetectionSignal
{
- signalID : String
- signalType : String
- severity : String
- sourceService : String
- detectedAt : DateTime

+ isCritical() : Boolean
}

class Incident
{
- incidentID : String
- status : String
- priority : String
- relatedSignals : List<DetectionSignal>
- contextData : Map<String, String>
- occurrenceCount : int

+ addSignal(signal : DetectionSignal) : void
+ updateStatus(status : String) : void
+ escalate() : void
}

class Playbook
{
- playbookID : String
- name : String
- triggerSignal : String
- requiresApproval : Boolean
- steps : List<PlaybookStep>

+ getSteps() : List<PlaybookStep>
}


class PlaybookStep
{
- stepOrder : int
- actionType : String
- targetService : String
- command : String
- retryCount : int
}

class AuditLog
{
- auditID : String
- timestamp : DateTime
- componentName : String
- actionPerformed : String
- outcome : String
}

Service Classes

class LogIngestionService
{
- sourceType : String

+ collectLog(rawLog : String) : void
+ forwardLog(rawLog : String) : void
}

class LogProcessingService
{
- parsingRules : List<String>

+ parseLog(rawLog : String) : LogEvent
+ normalizeLog(event : LogEvent) : LogEvent
}


class DetectionService
{
- rules : RuleEngine
- anomalyDetector : AnomalyEngine

+ analyze(event : LogEvent) : DetectionSignal
}


class IncidentManagementService
{
- incidentStore : Map<String, Incident>

+ createIncident(signal : DetectionSignal) : Incident
+ correlateSignal(signal : DetectionSignal) : Incident
+ closeIncident(incidentID : String) : void
}


class ResponseAutomationEngine
{
- playbooks : Map<String, Playbook>

+ selectPlaybook(incident : Incident) : Playbook
+ decideResponse(incident : Incident) : String
}



class ResponseExecutor
{
+ executeAction(step : PlaybookStep) : void
+ reportExecutionStatus(status : String) : void
}


class NotificationService
{
+ notifyAnalyst(incident : Incident) : void
+ sendAlert(message : String) : void
}



class AuditService
{
+ recordAuditLog(log : AuditLog) : void
+ generateReport(incident : Incident) : List<AuditLog>
}


Simulation Interfaces

class RuleEngine
{
+ matchRule(event : LogEvent) : Boolean
}

class AnomalyEngine
{
+ detectAnomaly(event : LogEvent) : Boolean
}

<<interface>> SystemActuator
{
+ performAction(command : String, target : String) : Boolean
}

class ServiceRestartActuator
{
+ performAction(command : String, target : String) : Boolean
+ restartService(serviceName : String) : void
}

Relationships

LogIngestionService → LogProcessingService
Relationship Type: Association
Description: LogIngestionService forwards collected logs to LogProcessingService for further processing.

LogProcessingService → LogEvent
Relationship Type: Association
Description: LogProcessingService creates and processes LogEvent objects without owning their lifecycle.

DetectionService → LogEvent
Relationship Type: Association
Description: DetectionService analyzes LogEvent objects as input for detection logic.

DetectionService → DetectionSignal
Relationship Type: Association
Description: DetectionService generates DetectionSignal objects as detection output.

DetectionService → RuleEngine
Relationship Type: Association
Description: DetectionService uses RuleEngine to apply predefined detection rules.

DetectionService → AnomalyEngine
Relationship Type: Association
Description: DetectionService collaborates with AnomalyEngine for anomaly-based detection.

IncidentManagementService → DetectionSignal
Relationship Type: Association
Description: IncidentManagementService consumes DetectionSignal objects for correlation.

IncidentManagementService → Incident
Relationship Type: Association
Description: IncidentManagementService creates and manages Incident entities.

Incident (1) o-- DetectionSignal (*)
Relationship Type: Aggregation
Description: An Incident groups multiple DetectionSignals, but signals can exist independently.

ResponseAutomationEngine → Incident
Relationship Type: Association
Description: ResponseAutomationEngine evaluates Incident data to decide response strategy.

ResponseAutomationEngine → Playbook
Relationship Type: Association
Description: ResponseAutomationEngine selects appropriate Playbooks based on incident context.

Playbook (1) o-- PlaybookStep (*)
Relationship Type: Composition
Description: PlaybookSteps are tightly bound to a Playbook and cannot exist independently.

ResponseExecutor → PlaybookStep
Relationship Type: Association
Description: ResponseExecutor executes individual PlaybookSteps.

ResponseExecutor → SystemActuator
Relationship Type: Association
Description: ResponseExecutor uses SystemActuator interface to perform system-level actions.

ServiceRestartActuator ..|> SystemActuator
Relationship Type: Inheritance (Interface Realization)
Description: ServiceRestartActuator implements the SystemActuator interface.

NotificationService → Incident
Relationship Type: Association
Description: NotificationService accesses Incident data to notify analysts.

AuditService → AuditLog
Relationship Type: Composition
Description: AuditLog entries are created and owned by AuditService.

AuditService → Incident
Relationship Type: Association
Description: AuditService references Incident data for reporting and compliance auditing.
